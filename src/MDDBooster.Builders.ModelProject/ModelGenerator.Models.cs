namespace MDDBooster.Builders.ModelProject;

/// <summary>
/// ModelGenerator - Model class generation methods
/// </summary>
public partial class ModelGenerator
{
    /// <summary>
    /// Generate a C# model class for a model
    /// </summary>
    public string GenerateModelClass(MDDModel model)
    {
        return ErrorHandling.ExecuteSafely(() =>
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// Code generated by \"MDD Booster\"; DO NOT EDIT.");

            // Add standard using statements
            sb.AppendLine("using System.ComponentModel.DataAnnotations;");
            sb.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");

            // Add using statements for enums if the model uses any
            if (ModelUsesEnums(model))
            {
                sb.AppendLine($"using {GetEnumNamespace()};");
            }

            sb.AppendLine($"namespace {GetModelNamespace()};");
            sb.AppendLine();

            // Summary comment
            if (!string.IsNullOrEmpty(model.BaseModel.Description))
            {
                sb.AppendLine("/// <summary>");
                sb.AppendLine($"/// {model.BaseModel.Description}");
                sb.AppendLine("/// </summary>");
            }

            // Table attribute
            string tableName = StringHelper.NormalizeName(model.BaseModel.Name);
            sb.AppendLine($"[Table(name: \"{tableName}\")]");

            // Class declaration
            string classModifiers = model.BaseModel.IsAbstract ? "public abstract partial class" :
                                  (_config.UsePartialClasses ? "public partial class" : "public class");
            string className = model.BaseModel.Name;

            // Inheritance
            var inheritance = BuildInheritanceList(model);
            string inheritanceString = inheritance.Any() ? " : " + string.Join(", ", inheritance) : "";

            sb.AppendLine($"{classModifiers} {className}{inheritanceString}");
            sb.AppendLine("{");

            // Properties
            AppendProperties(sb, model);

            // Navigation properties
            if (_config.GenerateNavigationProperties)
            {
                AppendNavigationProperties(sb, model);
            }

            sb.AppendLine("}");
            return sb.ToString();
        },
        string.Empty,
        "Failed to generate model class for {ModelName}",
        model.BaseModel.Name);
    }

    private List<string> BuildInheritanceList(MDDModel model)
    {
        var inheritance = new List<string>();

        foreach (var inheritedItem in model.BaseModel.Inherits)
        {
            var isBaseClass = Document.Models.Any(m => m.BaseModel.Name == inheritedItem);
            var isInterface = Document.Interfaces.Any(i => i.BaseInterface.Name == inheritedItem);

            if (isBaseClass && !inheritance.Contains(inheritedItem))
            {
                inheritance.Insert(0, inheritedItem);
                AppLog.Debug("Added base class {BaseClass} to model {ModelName}", inheritedItem, model.BaseModel.Name);
            }
            else if ((isInterface || !isBaseClass) && !inheritance.Contains(inheritedItem))
            {
                inheritance.Add(inheritedItem);
                AppLog.Debug("Added interface {Interface} to model {ModelName}", inheritedItem, model.BaseModel.Name);
            }
        }

        return inheritance;
    }

    private void AppendProperties(StringBuilder sb, MDDModel model)
    {
        var allFields = ModelUtilities.GetAllFields(Document, model);
        var inheritedFieldNames = GetInheritedFieldNames(model);

        foreach (var field in allFields)
        {
            // Skip inherited fields
            if (inheritedFieldNames.Contains(field.BaseField.Name))
                continue;

            bool isDeclaredInModel = model.BaseModel.Fields.Any(f => f.Name == field.BaseField.Name);
            bool isFromInterface = IsFieldFromInterface(model, field);

            // Only include fields that are directly declared in this model or come from interfaces
            if (!isDeclaredInModel && !isFromInterface)
                continue;

            // Skip auto-generated index fields
            if (IsAutoGeneratedIndexField(field))
                continue;

            // All fields that reach this point should be included
            // The parser has already handled indentation and metadata correctly

            // Regular property (string for enum fields)
            AppendRegularProperty(sb, field);

            // Enum property for enum fields (only if configured to generate enum as string)
            if (_config.GenerateEnumAsString && IsEnumField(field))
            {
                AppendEnumProperty(sb, field);
            }
        }
    }

    private void AppendRegularProperty(StringBuilder sb, MDDField field)
    {
        // Property annotations using the helper
        string annotations = AttributeGenerationHelper.GeneratePropertyAnnotations(field, _config);
        if (!string.IsNullOrEmpty(annotations))
        {
            sb.AppendLine(annotations);
        }

        // Property definition
        string propertyType = TypeConversionHelper.GetCSharpType(field, Document, _config.UseNullableReferenceTypes);
        string propertyName = StringHelper.NormalizeName(field.BaseField.Name);

        string required = ShouldUseRequiredKeyword(field, propertyType) ? "required " : "";

        sb.AppendLine($"\tpublic {required}{propertyType} {propertyName} {{ get; set; }}");
        sb.AppendLine(); // Add blank line after each property
    }

    private void AppendEnumProperty(StringBuilder sb, MDDField field)
    {
        string enumTypeName = GetEnumTypeName(field);
        string fieldName = StringHelper.NormalizeName(field.BaseField.Name);
        string enumPropertyName = $"{fieldName}{_config.EnumPropertySuffix}";

        // Add attributes based on configuration
        if (_config.AddNotMappedToEnumProperties)
        {
            sb.AppendLine("\t[NotMapped]");
        }
        if (_config.AddIgnoreToEnumProperties)
        {
            sb.AppendLine("\t[Ignore]");
        }

        // Property with getter/setter that converts between string and enum
        string nullableMarker = field.BaseField.IsNullable ? "?" : "";
        string defaultValue = field.BaseField.IsNullable ? "null" : "default";
        string virtualKeyword = _config.MakeEnumPropertiesVirtual ? "virtual " : "";

        sb.AppendLine($"\tpublic {virtualKeyword}{enumTypeName}{nullableMarker} {enumPropertyName}");
        sb.AppendLine("\t{");

        if (field.BaseField.IsNullable)
        {
            // Nullable enum property
            sb.AppendLine($"\t\tget => string.IsNullOrEmpty({fieldName}) ? null : Enum.TryParse(typeof({enumTypeName}), {fieldName}, out var enumValue) ? ({enumTypeName})enumValue! : {defaultValue};");
            sb.AppendLine($"\t\tset => {fieldName} = value?.ToString() ?? string.Empty;");
        }
        else
        {
            // Non-nullable enum property
            sb.AppendLine($"\t\tget => Enum.TryParse(typeof({enumTypeName}), {fieldName}, out var enumValue) ? ({enumTypeName})enumValue! : {defaultValue};");
            sb.AppendLine($"\t\tset => {fieldName} = value.ToString();");
        }

        sb.AppendLine("\t}");
        sb.AppendLine(); // Add blank line after enum property
    }

    private void AppendNavigationProperties(StringBuilder sb, MDDModel model)
    {
        if (!_modelRelations.TryGetValue(model.BaseModel.Name, out var relations))
            return;

        foreach (var relation in relations)
        {
            if (model.Fields.Any(f => f.BaseField.Name == relation.PropertyName))
                continue;

            string propertyType = relation.IsToMany
                ? $"ICollection<{relation.TargetModel}>"
                : relation.TargetModel;

            string nullableMarker = _config.UseNullableReferenceTypes ? "?" : "";

            if (!relation.IsToMany && !string.IsNullOrEmpty(relation.NavigationField))
            {
                sb.AppendLine($"\t[ForeignKey(nameof({relation.NavigationField}))]");
            }

            sb.AppendLine($"\tpublic virtual {propertyType}{nullableMarker} {relation.PropertyName} {{ get; set; }}");
            sb.AppendLine();
        }
    }

    private bool IsEnumField(MDDField field)
    {
        // Check if field type is enum
        if (!string.IsNullOrEmpty(field.BaseField.Type) &&
            field.BaseField.Type.Equals("enum", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        // Check if field references an enum
        if (field.BaseField.IsReference && !string.IsNullOrEmpty(field.BaseField.ReferenceTarget))
        {
            return Document.Enums.Any(e => e.BaseEnum.Name == field.BaseField.ReferenceTarget);
        }

        // Check if there's an enum with the same name as the field type
        return !string.IsNullOrEmpty(field.BaseField.Type) &&
               Document.Enums.Any(e => e.BaseEnum.Name.Equals(field.BaseField.Type, StringComparison.OrdinalIgnoreCase));
    }

    private string GetEnumTypeName(MDDField field)
    {
        // Check custom field-to-enum mappings first
        foreach (var mapping in _config.FieldToEnumMappings)
        {
            if (field.BaseField.Name.Contains(mapping.Key, StringComparison.OrdinalIgnoreCase))
            {
                return mapping.Value;
            }
        }

        // If the field has a reference to an enum, use that enum's name
        if (field.BaseField.IsReference && !string.IsNullOrEmpty(field.BaseField.ReferenceTarget))
        {
            var targetEnum = Document.Enums.FirstOrDefault(e =>
                e.BaseEnum.Name == field.BaseField.ReferenceTarget);

            if (targetEnum != null)
            {
                return targetEnum.BaseEnum.Name;
            }
        }

        // Check if the field has a nested type definition in extended metadata
        if (field.ExtendedMetadata.TryGetValue("type", out var enumTypeFromMetadata))
        {
            var enumTypeName = enumTypeFromMetadata.ToString();
            if (Document.Enums.Any(e => e.BaseEnum.Name.Equals(enumTypeName, StringComparison.OrdinalIgnoreCase)))
            {
                return enumTypeName;
            }
        }

        // Check if the field has a nested type definition in base metadata
        if (field.BaseField.Metadata.Any())
        {
            var typeMetadata = field.BaseField.Metadata.FirstOrDefault(kvp =>
                kvp.Key.Equals("type", StringComparison.OrdinalIgnoreCase));

            if (typeMetadata.Key != null)
            {
                string typeName = typeMetadata.Value?.ToString();
                var matchingEnum = Document.Enums.FirstOrDefault(e =>
                    e.BaseEnum.Name.Equals(typeName, StringComparison.OrdinalIgnoreCase));

                if (matchingEnum != null)
                {
                    return matchingEnum.BaseEnum.Name;
                }
            }
        }

        // Check if Field Type exactly matches any enum name
        var enumByType = !string.IsNullOrEmpty(field.BaseField.Type) ? Document.Enums.FirstOrDefault(e =>
            e.BaseEnum.Name.Equals(field.BaseField.Type, StringComparison.OrdinalIgnoreCase)) : null;

        if (enumByType != null)
        {
            return enumByType.BaseEnum.Name;
        }

        // Try intelligent field name to enum matching
        return FindEnumByFieldName(field.BaseField.Name, Document);
    }

    private string FindEnumByFieldName(string fieldName, MDDDocument document)
    {
        // Try exact field name match first
        var exactMatch = document.Enums.FirstOrDefault(e =>
            e.BaseEnum.Name.Equals(fieldName, StringComparison.OrdinalIgnoreCase));
        if (exactMatch != null)
        {
            return exactMatch.BaseEnum.Name;
        }

        // Try field name with common enum suffixes
        var enumSuffixes = new[] { "s", "Type", "Types", "Status", "Statuses", "Kind", "Kinds", "Roles", "States" };
        foreach (var suffix in enumSuffixes)
        {
            var enumWithSuffix = document.Enums.FirstOrDefault(e =>
                e.BaseEnum.Name.Equals(fieldName + suffix, StringComparison.OrdinalIgnoreCase));
            if (enumWithSuffix != null)
            {
                return enumWithSuffix.BaseEnum.Name;
            }
        }

        // Try removing common suffixes from field name and then adding enum suffixes
        var fieldNameVariations = new[]
        {
            fieldName.Replace("Type", "").Replace("Status", "").Replace("Kind", ""),
            fieldName.TrimEnd('s'),
            fieldName
        };

        foreach (var variation in fieldNameVariations.Where(v => !string.IsNullOrEmpty(v)))
        {
            foreach (var suffix in enumSuffixes)
            {
                var potentialEnumName = variation + suffix;
                var matchingEnum = document.Enums.FirstOrDefault(e =>
                    e.BaseEnum.Name.Equals(potentialEnumName, StringComparison.OrdinalIgnoreCase));
                if (matchingEnum != null)
                {
                    return matchingEnum.BaseEnum.Name;
                }
            }
        }

        // Look for partial matches
        var partialMatch = document.Enums.FirstOrDefault(e =>
            e.BaseEnum.Name.Contains(fieldName, StringComparison.OrdinalIgnoreCase) ||
            fieldName.Contains(e.BaseEnum.Name, StringComparison.OrdinalIgnoreCase));

        if (partialMatch != null)
        {
            return partialMatch.BaseEnum.Name;
        }

        // Return the first enum if any exist, otherwise return a default
        return document.Enums.FirstOrDefault()?.BaseEnum.Name ?? "object";
    }

    private HashSet<string> GetInheritedFieldNames(MDDModel model)
    {
        var inheritedFieldNames = new HashSet<string>();

        foreach (var inheritedClassName in model.BaseModel.Inherits)
        {
            if (Document.Interfaces.Any(i => i.BaseInterface.Name == inheritedClassName))
                continue;

            var baseClassModel = Document.Models.FirstOrDefault(m => m.BaseModel.Name == inheritedClassName);
            if (baseClassModel != null)
            {
                var baseClassFields = ModelUtilities.GetAllFields(Document, baseClassModel);
                foreach (var field in baseClassFields)
                {
                    inheritedFieldNames.Add(field.BaseField.Name);
                }
            }
        }

        return inheritedFieldNames;
    }

    private bool IsFieldFromInterface(MDDModel model, MDDField field)
    {
        return model.BaseModel.Inherits.Any(i =>
            Document.Interfaces.Any(iface => iface.BaseInterface.Name == i &&
                                          iface.Fields.Any(f => f.BaseField.Name == field.BaseField.Name)));
    }

    private bool ShouldUseRequiredKeyword(MDDField field, string propertyType)
    {
        return field.BaseField.IsRequired &&
               !field.BaseField.IsNullable &&
               TypeConversionHelper.IsReferenceType(propertyType) &&
               _config.UseNullableReferenceTypes;
    }

    private bool ModelUsesEnums(MDDModel model)
    {
        var allFields = ModelUtilities.GetAllFields(Document, model);
        return allFields.Any(field => IsEnumField(field));
    }

    private bool IsAutoGeneratedIndexField(MDDField field)
    {
        // Skip fields that are auto-generated from @index attributes
        var fieldName = field.BaseField.Name;

        // Check if this is an @index directive (these should be filtered out)
        if (fieldName.StartsWith("@index", StringComparison.OrdinalIgnoreCase))
        {
            AppLog.Information("Filtering @index directive: {FieldName}", fieldName);
            return true;
        }

        // Check for auto-generated index fields with "Index" prefix
        // Pattern: fields starting with "Index" followed by concatenated field names
        // Examples: "IndexTargetTypeTargetId", "IndexSeriesIdSeriesOrder", "IndexStatusCreatedAt"
        if (fieldName.StartsWith("Index", StringComparison.OrdinalIgnoreCase) &&
            fieldName.Length > 5)
        {
            var afterIndex = fieldName.Substring(5);

            // Must contain at least one uppercase letter (indicating camelCase concatenation)
            // and should NOT be a regular field that just happens to start with "Index"
            if (afterIndex.Any(char.IsUpper))
            {
                // Additional check: if it contains common concatenation patterns
                // like multiple uppercase letters separated by lowercase
                var uppercaseCount = afterIndex.Count(char.IsUpper);
                bool isIndexField = uppercaseCount >= 2; // At least 2 uppercase letters indicates field concatenation

                if (isIndexField)
                {
                    AppLog.Information("Filtering auto-generated index field: {FieldName}", fieldName);
                    return true;
                }
            }
        }

        return false;
    }
}