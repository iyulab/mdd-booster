namespace MDDBooster.Builders.ModelProject.Utilities;

/// <summary>
/// Generates GraphQL search request classes
/// </summary>
internal class GqlSearchRequestGenerator
{
    private readonly ModelTypeConverter _typeConverter;
    private readonly ModelProjectConfig _config;

    internal GqlSearchRequestGenerator(ModelTypeConverter typeConverter, ModelProjectConfig config)
    {
        _typeConverter = typeConverter;
        _config = config;
    }

    /// <summary>
    /// Generate GraphQL search request classes for a model
    /// </summary>
    internal string GenerateSearchRequestClasses(MDDDocument document, MDDModel model)
    {
        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// Code generated by \"MDD Booster\"; DO NOT EDIT.");
        sb.AppendLine("#pragma warning disable CS8618, IDE1006");
        sb.AppendLine($"namespace {GetNamespace()}");
        sb.AppendLine("{");

        // Single item search request
        GenerateSingleSearchRequest(sb, model);
        sb.AppendLine();

        // Multiple items search request
        GenerateMultipleSearchRequest(sb, document, model);

        sb.AppendLine("}");
        sb.AppendLine("#pragma warning restore CS8618, IDE1006");

        return sb.ToString();
    }

    private void GenerateSingleSearchRequest(StringBuilder sb, MDDModel model)
    {
        string className = $"{model.BaseModel.Name}SearchRequest";
        string interfaceName = $"IGqlSearchRequest<{model.BaseModel.Name}>";

        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Single {model.BaseModel.Name} search request");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public class {className} : {interfaceName}");
        sb.AppendLine("    {");
        sb.AppendLine("        public Guid _id { get; set; }");
        sb.AppendLine("        public string[] Columns { get; set; }");
        sb.AppendLine("    }");
    }

    private void GenerateMultipleSearchRequest(StringBuilder sb, MDDDocument document, MDDModel model)
    {
        string className = $"{model.BaseModel.Name}sSearchRequest";
        string interfaceName = $"IGqlSearchRequest<{model.BaseModel.Name}>";

        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Multiple {model.BaseModel.Name} search request with pagination");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public class {className} : PageRequestBase, {interfaceName}");
        sb.AppendLine("    {");

        // Get all fields including inherited ones
        var allFields = ModelUtilities.GetAllFields(document, model);

        // Filter out primary key fields and add search properties for searchable fields
        var searchableFields = allFields.Where(f =>
            !f.BaseField.IsPrimaryKey &&
            IsSearchableField(f) &&
            !ShouldExcludeFromSearch(f)).ToList();

        foreach (var field in searchableFields)
        {
            GenerateSearchProperty(sb, field);
        }

        // Always include IDs array for bulk operations
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Array of specific IDs to search for");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public Guid[]? _ids { get; set; }");

        // Add date range search properties for date fields
        var dateFields = searchableFields.Where(f => IsDateTimeField(f)).ToList();
        if (dateFields.Any())
        {
            sb.AppendLine();
            sb.AppendLine("        // Date range filters");
            foreach (var dateField in dateFields)
            {
                string fieldName = StringHelper.NormalizeName(dateField.BaseField.Name);
                string dateType = _config.UseDateTimeOffset ? "DateTimeOffset" : "DateTime";
                string nullableMarker = "?";

                sb.AppendLine($"        public {dateType}{nullableMarker} {fieldName}From {{ get; set; }}");
                sb.AppendLine($"        public {dateType}{nullableMarker} {fieldName}To {{ get; set; }}");
            }
        }

        sb.AppendLine("    }");
    }

    private void GenerateSearchProperty(StringBuilder sb, MDDField field)
    {
        string propertyName = field.BaseField.Name.ToPlural();
        string propertyType = GetSearchPropertyType(field);
        string nullableMarker = _config.UseNullableReferenceTypes && propertyType.IsReferenceType() ? "?" : "";

        // Add summary comment
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Search by {field.BaseField.Name} values");
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        public {propertyType}[]{nullableMarker} {propertyName} {{ get; set; }}");
    }

    private string GetSearchPropertyType(MDDField field)
    {
        // For reference fields, use Guid
        if (field.BaseField.IsReference)
        {
            return "Guid";
        }

        return field.BaseField.Type.ToLowerInvariant() switch
        {
            "identifier" or "guid" => "Guid",
            "integer" => "int",
            "decimal" => "decimal",
            "boolean" => "bool",
            "datetime" or "timestamp" or "date" => _config.UseDateTimeOffset ? "DateTimeOffset" : "DateTime",
            "enum" => _typeConverter.GetEnumType(field),
            _ => "string"
        };
    }

    private bool IsSearchableField(MDDField field)
    {
        // Check if field is marked as not searchable
        if (field.ExtendedMetadata.ContainsKey("NotSearchable") &&
            (bool)field.ExtendedMetadata["NotSearchable"])
        {
            return false;
        }

        // Most fields are searchable except computed ones
        return !IsComputedField(field);
    }

    private bool ShouldExcludeFromSearch(MDDField field)
    {
        // Exclude sensitive fields from search by default
        if (field.ExtendedMetadata.ContainsKey("Sensitive") &&
            (bool)field.ExtendedMetadata["Sensitive"])
        {
            return true;
        }

        // Exclude password fields
        if (field.BaseField.Name.Contains("Password", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        // Exclude very large text fields
        if (field.BaseField.Type.ToLowerInvariant() == "text" &&
            field.BaseField.Name.Contains("Content", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }

        return false;
    }

    private bool IsComputedField(MDDField field)
    {
        return field.ExtendedMetadata.ContainsKey("Computed") &&
               (bool)field.ExtendedMetadata["Computed"];
    }

    private bool IsDateTimeField(MDDField field)
    {
        var fieldType = field.BaseField.Type.ToLowerInvariant();
        return fieldType == "datetime" || fieldType == "timestamp" || fieldType == "date";
    }

    private string GetNamespace()
    {
        string baseNamespace = string.IsNullOrEmpty(_config.Namespace) ? "DefaultNamespace" : _config.Namespace;

        // If GqlSearchRequestPath ends with underscore, use "Gql" as folder name
        if (_config.GqlSearchRequestPath.EndsWith("_"))
        {
            return $"{baseNamespace}.Gql";
        }

        string folderName = Path.GetFileName(_config.GqlSearchRequestPath);
        return $"{baseNamespace}.{folderName}";
    }
}