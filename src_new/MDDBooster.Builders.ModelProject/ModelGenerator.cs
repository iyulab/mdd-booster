namespace MDDBooster.Builders.ModelProject;

/// <summary>
/// Generator for C# model classes
/// </summary>
public class ModelGenerator
{
    public MDDDocument Document { get; }
    private readonly ModelProjectConfig _config;
    private readonly Dictionary<string, List<RelationInfo>> _modelRelations;
    private readonly ModelTypeConverter _typeConverter;
    private readonly ModelAttributeGenerator _attributeGenerator;
    private readonly GqlSearchRequestGenerator _gqlSearchRequestGenerator;

    private class RelationInfo
    {
        public string SourceModel { get; set; }
        public string TargetModel { get; set; }
        public string PropertyName { get; set; }
        public bool IsToMany { get; set; }
        public string NavigationField { get; set; }
        public bool IsForeignKey { get; set; }
    }

    public ModelGenerator(MDDDocument document, ModelProjectConfig config)
    {
        Document = document;
        _config = config;
        _typeConverter = new ModelTypeConverter(document, config);
        _attributeGenerator = new ModelAttributeGenerator(_typeConverter, config);
        _gqlSearchRequestGenerator = new GqlSearchRequestGenerator(_typeConverter, config);
        _modelRelations = BuildRelationshipMap();
    }

    /// <summary>
    /// Generate a C# model class for a model
    /// </summary>
    public string GenerateModelClass(MDDModel model)
    {
        return ErrorHandling.ExecuteSafely(() =>
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// Code generated by \"MDD Booster\"; DO NOT EDIT.");
            sb.AppendLine($"namespace {GetNamespace(model)};");
            sb.AppendLine();

            // Summary comment
            if (!string.IsNullOrEmpty(model.BaseModel.Description))
            {
                sb.AppendLine("/// <summary>");
                sb.AppendLine($"/// {model.BaseModel.Description}");
                sb.AppendLine("/// </summary>");
            }

            // Table attribute
            string tableName = StringHelper.NormalizeName(model.BaseModel.Name);
            sb.AppendLine($"[Table(name: \"{tableName}\")]");

            // Class declaration
            string classModifiers = model.BaseModel.IsAbstract ? "public abstract partial class" :
                                  (_config.UsePartialClasses ? "public partial class" : "public class");
            string className = model.BaseModel.Name;

            // Inheritance
            var inheritance = new List<string>();
            foreach (var inheritedItem in model.BaseModel.Inherits)
            {
                var isBaseClass = Document.Models.Any(m => m.BaseModel.Name == inheritedItem);
                var isInterface = Document.Interfaces.Any(i => i.BaseInterface.Name == inheritedItem);

                if (isBaseClass && !inheritance.Contains(inheritedItem))
                {
                    inheritance.Insert(0, inheritedItem);
                    AppLog.Debug("Added base class {BaseClass} to model {ModelName}", inheritedItem, model.BaseModel.Name);
                }
                else if ((isInterface || !isBaseClass) && !inheritance.Contains(inheritedItem))
                {
                    inheritance.Add(inheritedItem);
                    AppLog.Debug("Added interface {Interface} to model {ModelName}", inheritedItem, model.BaseModel.Name);
                }
            }

            string inheritanceString = inheritance.Any() ? " : " + string.Join(", ", inheritance) : "";

            sb.AppendLine($"{classModifiers} {className}{inheritanceString}");
            sb.AppendLine("{");

            // Properties
            AppendProperties(sb, model);

            // Navigation properties
            if (_config.GenerateNavigationProperties)
            {
                AppendNavigationProperties(sb, model);
            }

            sb.AppendLine("}");
            return sb.ToString();
        },
        string.Empty,
        "Failed to generate model class for {ModelName}",
        model.BaseModel.Name);
    }

    /// <summary>
    /// Generate a C# interface
    /// </summary>
    public string GenerateInterface(MDDInterface iface)
    {
        return ErrorHandling.ExecuteSafely(() =>
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// Code generated by \"MDD Booster\"; DO NOT EDIT.");
            sb.AppendLine($"namespace {GetNamespace(iface)};");
            sb.AppendLine();

            // Summary comment
            if (!string.IsNullOrEmpty(iface.BaseInterface.Description))
            {
                sb.AppendLine("/// <summary>");
                sb.AppendLine($"/// {iface.BaseInterface.Description}");
                sb.AppendLine("/// </summary>");
            }

            // Interface declaration
            string inheritance = iface.BaseInterface.Inherits.Any()
                ? " : " + string.Join(", ", iface.BaseInterface.Inherits)
                : "";

            sb.AppendLine($"public interface {iface.BaseInterface.Name}{inheritance}");
            sb.AppendLine("{");

            // Properties
            var directFields = iface.Fields.Where(f =>
                iface.BaseInterface.Fields.Any(bf => bf.Name == f.BaseField.Name)).ToList();

            foreach (var field in directFields)
            {
                AppendInterfaceProperty(sb, field);
            }

            sb.AppendLine("}");
            return sb.ToString();
        },
        string.Empty,
        "Failed to generate interface for {InterfaceName}",
        iface.BaseInterface.Name);
    }

    /// <summary>
    /// Generate a C# enum
    /// </summary>
    public string GenerateEnum(MDDEnum enum_)
    {
        return ErrorHandling.ExecuteSafely(() =>
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// Code generated by \"MDD Booster\"; DO NOT EDIT.");
            sb.AppendLine($"namespace {GetNamespace(enum_)};");
            sb.AppendLine();

            // Summary comment
            if (!string.IsNullOrEmpty(enum_.BaseEnum.Description))
            {
                sb.AppendLine("/// <summary>");
                sb.AppendLine($"/// {enum_.BaseEnum.Description}");
                sb.AppendLine("/// </summary>");
            }

            // Enum declaration
            sb.AppendLine($"public enum {enum_.BaseEnum.Name}");
            sb.AppendLine("{");

            // Enum values
            for (int i = 0; i < enum_.BaseEnum.Values.Count; i++)
            {
                var value = enum_.BaseEnum.Values[i];

                if (!string.IsNullOrEmpty(value.Description))
                {
                    sb.AppendLine("    /// <summary>");
                    sb.AppendLine($"    /// {value.Description}");
                    sb.AppendLine("    /// </summary>");
                }

                string enumValue = string.IsNullOrEmpty(value.Value) ? "" : $" = {value.Value}";
                string comma = i < enum_.BaseEnum.Values.Count - 1 ? "," : "";

                sb.AppendLine($"    {value.Name}{enumValue}{comma}");
            }

            sb.AppendLine("}");
            return sb.ToString();
        },
        string.Empty,
        "Failed to generate enum for {EnumName}",
        enum_.BaseEnum.Name);
    }

    /// <summary>
    /// Generate GraphQL search request classes for a model
    /// </summary>
    public string GenerateGqlSearchRequestClasses(MDDModel model)
    {
        return ErrorHandling.ExecuteSafely(() =>
        {
            return _gqlSearchRequestGenerator.GenerateSearchRequestClasses(Document, model);
        },
        string.Empty,
        "Failed to generate GraphQL search request classes for {ModelName}",
        model.BaseModel.Name);
    }

    private void AppendProperties(StringBuilder sb, MDDModel model)
    {
        var allFields = ModelUtilities.GetAllFields(Document, model);
        var inheritedFieldNames = new HashSet<string>();

        foreach (var inheritedClassName in model.BaseModel.Inherits)
        {
            if (Document.Interfaces.Any(i => i.BaseInterface.Name == inheritedClassName))
                continue;

            var baseClassModel = Document.Models.FirstOrDefault(m => m.BaseModel.Name == inheritedClassName);
            if (baseClassModel != null)
            {
                var baseClassFields = ModelUtilities.GetAllFields(Document, baseClassModel);
                foreach (var field in baseClassFields)
                {
                    inheritedFieldNames.Add(field.BaseField.Name);
                }
            }
        }

        foreach (var field in allFields)
        {
            if (inheritedFieldNames.Contains(field.BaseField.Name))
                continue;

            bool isDeclaredInModel = model.BaseModel.Fields.Any(f => f.Name == field.BaseField.Name);
            bool isFromInterface = model.BaseModel.Inherits.Any(i =>
                Document.Interfaces.Any(iface => iface.BaseInterface.Name == i &&
                                              iface.Fields.Any(f => f.BaseField.Name == field.BaseField.Name)));

            if (!isDeclaredInModel && !isFromInterface)
                continue;

            // Property annotations
            sb.Append(_attributeGenerator.GeneratePropertyAnnotations(field));

            // Property definition
            string propertyType = _typeConverter.GetCSharpType(field);
            string propertyName = StringHelper.NormalizeName(field.BaseField.Name);

            string required = (field.BaseField.IsRequired && !field.BaseField.IsNullable &&
                              _typeConverter.IsReferenceType(field.BaseField.Type) && _config.UseNullableReferenceTypes)
                ? "required " : "";

            sb.AppendLine($"\tpublic {required}{propertyType} {propertyName} {{ get; set; }}");
            sb.AppendLine();
        }
    }

    private void AppendNavigationProperties(StringBuilder sb, MDDModel model)
    {
        if (!_modelRelations.TryGetValue(model.BaseModel.Name, out var relations))
            return;

        foreach (var relation in relations)
        {
            if (model.Fields.Any(f => f.BaseField.Name == relation.PropertyName))
                continue;

            string propertyType = relation.IsToMany
                ? $"ICollection<{relation.TargetModel}>"
                : relation.TargetModel;

            string nullableMarker = _config.UseNullableReferenceTypes ? "?" : "";

            if (!relation.IsToMany && !string.IsNullOrEmpty(relation.NavigationField))
            {
                sb.AppendLine($"\t[ForeignKey(nameof({relation.NavigationField}))]");
            }

            sb.AppendLine($"\tpublic virtual {propertyType}{nullableMarker} {relation.PropertyName} {{ get; set; }}");
            sb.AppendLine();
        }
    }

    private void AppendInterfaceProperty(StringBuilder sb, MDDField field)
    {
        string propertyType = _typeConverter.GetCSharpType(field);
        string propertyName = StringHelper.NormalizeName(field.BaseField.Name);

        if (!string.IsNullOrEmpty(field.BaseField.Description))
        {
            sb.AppendLine("\t/// <summary>");
            sb.AppendLine($"\t/// {field.BaseField.Description}");
            sb.AppendLine("\t/// </summary>");
        }

        sb.AppendLine($"\t{propertyType} {propertyName} {{ get; set; }}");
        sb.AppendLine();
    }

    private Dictionary<string, List<RelationInfo>> BuildRelationshipMap()
    {
        var relationMap = new Dictionary<string, List<RelationInfo>>();

        foreach (var model in Document.Models)
        {
            foreach (var field in model.Fields)
            {
                if (!field.BaseField.IsReference || string.IsNullOrEmpty(field.BaseField.ReferenceTarget))
                    continue;

                string targetModelName = field.BaseField.ReferenceTarget;
                string sourceModelName = model.BaseModel.Name;
                string fieldName = field.BaseField.Name;

                string navigationPropertyName = GetNavigationPropertyName(targetModelName, fieldName);
                AddRelationship(relationMap, sourceModelName, targetModelName, navigationPropertyName, false, fieldName, true);

                string backrefPropertyName = GetBackReferencePropertyName(sourceModelName, fieldName);
                AddRelationship(relationMap, targetModelName, sourceModelName, backrefPropertyName, true);
            }
        }

        foreach (var model in Document.Models)
        {
            foreach (var relation in model.BaseModel.Relations)
            {
                if (string.IsNullOrEmpty(relation.Target))
                    continue;

                string sourceModelName = model.BaseModel.Name;
                string targetModelName = relation.Target;
                string propertyName = relation.Name;
                string foreignKeyField = !string.IsNullOrEmpty(relation.From) ? relation.From : null;

                AddRelationship(relationMap, sourceModelName, targetModelName, propertyName, !relation.IsToOne, foreignKeyField);

                if (relation.IsToOne)
                {
                    string backrefPropertyName = GetCollectionPropertyName(sourceModelName);
                    AddRelationship(relationMap, targetModelName, sourceModelName, backrefPropertyName, true);
                }
            }
        }

        return relationMap;
    }

    private void AddRelationship(Dictionary<string, List<RelationInfo>> relationMap, string sourceModel,
        string targetModel, string propertyName, bool isToMany, string navigationField = null, bool isForeignKey = false)
    {
        if (!relationMap.ContainsKey(sourceModel))
        {
            relationMap[sourceModel] = new List<RelationInfo>();
        }

        var existingRelation = relationMap[sourceModel]
            .FirstOrDefault(r => r.TargetModel == targetModel && r.PropertyName == propertyName);

        if (existingRelation == null)
        {
            relationMap[sourceModel].Add(new RelationInfo
            {
                SourceModel = sourceModel,
                TargetModel = targetModel,
                PropertyName = propertyName,
                IsToMany = isToMany,
                NavigationField = navigationField,
                IsForeignKey = isForeignKey
            });
        }
        else if (!string.IsNullOrEmpty(navigationField))
        {
            existingRelation.NavigationField = navigationField;
            existingRelation.IsForeignKey = isForeignKey;
        }
    }

    private string GetCollectionPropertyName(string modelName) => $"{modelName}s";

    private string GetBackReferencePropertyName(string modelName, string fieldName)
    {
        if (fieldName.Contains(modelName, StringComparison.OrdinalIgnoreCase))
        {
            return $"{fieldName}s";
        }
        return GetCollectionPropertyName(modelName);
    }

    private string GetNavigationPropertyName(string targetModelName, string fieldName)
    {
        if (fieldName.EndsWith("_id", StringComparison.OrdinalIgnoreCase))
        {
            string baseName = fieldName.Substring(0, fieldName.Length - 3);
            if (string.Equals(baseName, targetModelName, StringComparison.OrdinalIgnoreCase))
            {
                return targetModelName;
            }
            return baseName;
        }

        if (fieldName.Contains(targetModelName, StringComparison.OrdinalIgnoreCase))
        {
            int idx = fieldName.IndexOf(targetModelName, StringComparison.OrdinalIgnoreCase);
            if (idx == 0)
            {
                return targetModelName;
            }

            if (fieldName.EndsWith("Id", StringComparison.OrdinalIgnoreCase))
            {
                return fieldName.Substring(0, fieldName.Length - 2);
            }
        }

        return targetModelName;
    }

    private string GetNamespace(MDDModel model)
    {
        string baseNamespace = string.IsNullOrEmpty(_config.Namespace) ? Document.BaseDocument.Namespace : _config.Namespace;

        if (_config.ModelsPath.EndsWith("_"))
        {
            return $"{baseNamespace}.Entity";
        }

        string folderName = Path.GetFileName(_config.ModelsPath);
        return $"{baseNamespace}.{folderName}";
    }

    private string GetNamespace(MDDInterface iface)
    {
        string baseNamespace = string.IsNullOrEmpty(_config.Namespace) ? Document.BaseDocument.Namespace : _config.Namespace;

        if (_config.InterfacesPath.EndsWith("_"))
        {
            return $"{baseNamespace}.Models";
        }

        string folderName = Path.GetFileName(_config.InterfacesPath);
        return $"{baseNamespace}.{folderName}";
    }

    private string GetNamespace(MDDEnum enum_)
    {
        string baseNamespace = string.IsNullOrEmpty(_config.Namespace) ? Document.BaseDocument.Namespace : _config.Namespace;

        if (_config.EnumsPath.EndsWith("_"))
        {
            return $"{baseNamespace}.Models";
        }

        string folderName = Path.GetFileName(_config.EnumsPath);
        return $"{baseNamespace}.{folderName}";
    }
}